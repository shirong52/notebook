---


---

<h3 id="、回文子串">1、回文子串</h3>
<ul>
<li>dp[i][j]：[i,j]范围内的子串是否为回文子串True/False</li>
<li>if (s[i] == s[j]) （有三种情况：i=j，i与j相差1，j-i &gt; 1）</li>
<li>dp[i][j] = False</li>
<li>从左下角推的递推公式，故递归顺序为从下往上从左往右</li>
</ul>
<h3 id="、最长回文子序列">2、最长回文子序列</h3>
<ul>
<li>dp[i][j]：[i,j]范围内的最长回文子序列长度</li>
<li>if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2（相同情况，加上这两边）else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</li>
<li>dp[i][i] = 1（都相同的情况下都初始化为1，因为有一个字母它是回文的）</li>
<li>从下往上从左往右，i=j的情况已经初始化过了，故j从i + 1开始</li>
<li>输出为dp[0][len(s)-1]，因为要求范围内最长的回文子序列</li>
</ul>
<h3 id="、单调栈">3、单调栈</h3>
<p>适合求解问题</p>
<ul>
<li>求当前元素左边或者右边第一个比当前元素大或者小的元素</li>
</ul>
<p>何为单调栈</p>
<ul>
<li>保证栈里的元素单增或单减</li>
<li>栈里放下标，通过映射获取数值</li>
<li>递增：求当前元素以左或以右第一个比他大的元素的位置；递减：求当前元素以左或以右第一个比他小的元素的位置</li>
</ul>
<p>单调栈的作用</p>
<ul>
<li>存放遍历过的元素，并和当前遍历的元素做对比</li>
</ul>
<p>单调栈解题</p>
<ul>
<li>得到计算结果后将其弹出</li>
<li>初始化为0，未弹出的结果就为0</li>
</ul>

