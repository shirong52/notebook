---


---

<h2 id="代码随想录">代码随想录</h2>
<h3 id="、无重叠区间">1、无重叠区间</h3>
<ul>
<li>求无重叠区间实际上就是求有多少个区间重叠，统计并输出，删除重叠区间</li>
<li>进行排序（可按左边界也可按右边界）</li>
</ul>
<h3 id="、划分字母区间">2、划分字母区间</h3>
<ul>
<li>统计每个字符的最远位置，以囊括所有的该字符</li>
<li>整体分为两步：一、记录每一个元素的最远出现位置；二、遍历字符串时根据最远出现位置来决定区间的分界线</li>
<li>用一个数组获得每个字母最远的出现位置——通过遍历</li>
</ul>
<h3 id="、合并区间">3、合并区间</h3>
<ul>
<li>类似的</li>
<li>直接在result数组里面进行修改</li>
</ul>
<h3 id="、单调递增的数字">4、单调递增的数字</h3>
<ul>
<li>处理逻辑若两位不符合要求，要对前一位进行减一处理才可能，最后一位取最大值</li>
<li>遍历顺序：从前往后得到的数值不符合要求，因为前面可能有相同的情况（332）；从后往前遍历可以基于后面已经处理的结果继续进行处理</li>
<li>用flag来标记需要处理为9的位置，因为我发现一位一位改容易出问题；并且以1000为例，后面几位都相等，如果不全改为9的话结果会是900；还要注意flag的初始值要为最后一位，不然可能会对本身符合要求的数进行修改</li>
</ul>
<h3 id="、监控二叉树">5、监控二叉树</h3>
<ul>
<li>按照后序左右中进行遍历</li>
<li>对于叶子节点而言，要放在其父节点，使其尽量覆盖上中下三层；疑惑同样的道理为什么不运用在根节点，主要是因为叶子节点数比根节点数多</li>
<li>节点状态：0无覆盖，1有摄像头，2有覆盖</li>
<li>考虑空节点的状态为有覆盖，让叶子节点父节点有摄像头，因为其他两种状态不符合设计原则</li>
<li>四种情况：1.左右孩都有覆盖，其为无覆盖，则应在其父节点加摄像头；2.左右至少有一个无覆盖；3.左右孩子至少有一个有摄像头；4.遍历完了根节点无覆盖，必须要再加一个摄像头</li>
</ul>

