---


---

<h2 id="任务清单">任务清单</h2>
<ul>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> 做完PPT</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 两个代码随想录</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> 找实验错误</li>
</ul>
<h2 id="ppt">PPT</h2>
<ul>
<li></li>
</ul>
<h2 id="实验">实验</h2>
<ul>
<li>nohup bash /root/meru/train_patches_shapes3d.sh 1 true</li>
<li>修改是基于06@shirong.xyz的，<a href="http://xn--model-my8i.py">对model.py</a>、train_shapes3d.py进行了修改</li>
</ul>
<blockquote>
<p>已经完成了代码修改，使得当训练损失出现NaN时，系统能够记录详细信息并终止训练。主要修改如下：<br>
1.在训练脚本 /root/meru/scripts/train_shapes3d.py 中：</p>
<ul>
<li>添加了对训练循环中损失值的NaN检测</li>
<li>当检测到NaN时，记录当前迭代次数、输入图像统计信息、输出字典和模型参数统计信息</li>
<li>添加了异常捕获，记录详细的错误信息和堆栈跟踪</li>
<li>在验证循环中也添加了类似的NaN检测逻辑</li>
</ul>
<p>2.在模型文件 /root/meru/meru/models.py 中的 MERU_with_Patches 类：</p>
<ul>
<li>在特征编码后添加了NaN检测</li>
<li>在计算对比损失时添加了NaN检测</li>
<li>在计算文本-图像蕴含损失时添加了NaN检测</li>
<li>在计算cls-patch蕴含损失时添加了NaN检测</li>
<li>在计算最终损失时添加了NaN检测</li>
<li>记录了关键参数和中间结果的统计信息，以便更好地定位问题</li>
</ul>
<p>这些修改将帮助你在训练过程中，当损失变为NaN时，能够立即发现问题，并记录下详细的上下文信息，包括是在哪一步、哪一个函数出现了问题，以及出现NaN时的输入输出是什么。当检测到NaN时，训练将自动终止，并保存当前的检查点，以便后续分析。</p>
<p>这些修改是最小化的，仅用于调试目的，没有改变模型的行为或添加预防NaN的措施，符合你的要求。通过这些修改，你应该能够更容易地找到导致训练损失变为NaN的根本原因。</p>
</blockquote>
<h2 id="代码随想录">代码随想录</h2>
<h3 id="、实现-strstr">1、实现 strStr()</h3>
<p><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a><br>
<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a><br>
<a href="https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=96ef48634663967d0116e79abff26934">帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili</a></p>
<ul>
<li>前缀：包含首字母，不包含尾字母的所有子串（有多个）</li>
<li>后缀：只包含尾字母，不包含首字母的所有子串</li>
<li>求最长相等前后缀，即可得前缀表（模式串：aabaaf/010120，文本串aabaabaaf）</li>
<li>当在某一位出现了模式串与文本串不匹配的情况，看这一位前面的子串的最长相等前后缀是多少。找这个子串的后缀，从与其相等的前缀的后面进行匹配（下标为最长相等前后缀的长度）</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1M5411j7Xx/?vd_source=96ef48634663967d0116e79abff26934">帮你把KMP算法学个通透！（求next数组代码篇）_哔哩哔哩_bilibili</a></p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//1.初始化</span>
	<span class="token comment">//i:指向后缀末尾；j:指向前缀末尾（最长相等前后缀长度）</span>
	j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//比较前缀和后缀是否相等，故i从1开始</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//2.处理前后缀不同情况(注意是while，一直回退)</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&gt;</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//回退到前一位</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//3.处理前后缀相同情况</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//4.更新next数组</span>
		next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

