---


---

<h2 id="代码随想录">代码随想录</h2>
<h3 id="、整数拆分">1、整数拆分</h3>
<ul>
<li>确定dp[i]含义：dp[i]——对i进行拆分之后得到的最大乘积</li>
<li>递推公式：dp[i]=j * dp[i - j]</li>
<li>dp[i]数组如何初始化：dp[0]=0，dp[1]=0，dp[2]=1</li>
<li>遍历顺序：从前向后，3为初始值</li>
<li>打印dp数组</li>
</ul>
<h3 id="、不同的二叉搜索树">2、不同的二叉搜索树</h3>
<ul>
<li>确定dp[i]含义：dp[i]——多少种不同的二叉搜索树</li>
<li>递推公式：dp[i] += dp[j -1] * dp[i - j]（左子树和右子树）</li>
<li>dp[i]数组如何初始化：dp[0]=1，dp[1]=1</li>
<li>遍历顺序：从小到大</li>
<li>打印dp数组</li>
</ul>
<h3 id="、0-1背包问题基础">3、0-1背包问题基础</h3>
<p><strong>类别</strong></p>
<ul>
<li>0-1背包：n种物品，每种物品只有一个</li>
<li>完全背包：n种物品，每种物品有无限个</li>
<li>多种背包：n种物品，每种物品数量各不相同</li>
</ul>
<p><strong>暴力解法</strong></p>
<ul>
<li>每个物体两个状态：取/不取</li>
<li>使用回溯算法进行暴力搜索，枚举所有情况，时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li>
</ul>
<p><strong>背包问题——二维dp数组</strong></p>
<ul>
<li>确定dp[i][j]含义：dp[i][j]——下标[0,i]之间的物品任取放进容量为j的背包里</li>
<li>递推公式：dp[i][j] = max(dp[:-1][j], 后面那一项)不放物品i——dp[i - 1][j]，放物品i——dp[i - 1][j - weight[i]] + value[i]（不放物品i，背包的容量减去了物品i的容量之后所能放的最大价值，再加上物品i的价值）</li>
<li>dp[i]数组如何初始化：画个表格看一下如何初始化，是初始化第一行（物品0的价值）和第一列（容量全为0）；非零下标可以随意初始化，因为递推公式没有用到这个数本身，而是由左上和上方推导而来的</li>
<li>遍历顺序：两个for循环，外层为物品，内层为背包（二维dp数组实现的0-1背包顺序可以颠倒，因为左上和上方都有数据）</li>
<li>打印dp数组</li>
</ul>
<p><strong>背包问题——一维dp数组</strong></p>
<blockquote>
<p>滚动数组是把上一层的数组拷贝下来了</p>
</blockquote>
<ul>
<li>确定dp[i]含义：dp[j]——容量为j的背包所能装的最大价值</li>
<li>递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</li>
<li>dp[j]数组如何初始化：dp[0]=0，其他的非零数组也初始化为0（原因是递推公式要取最大值，初始化就要小一点不要让初始化影响到结果）</li>
<li>遍历顺序：先遍历物品，再遍历背包（不可颠倒）；倒序遍历——保证每个物品只被添加过一次</li>
<li>打印dp数组</li>
</ul>

