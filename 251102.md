---


---

<h3 id="、最长公共子序列">1、最长公共子序列</h3>
<ul>
<li>dp[i][j]：以(0, i - 1]的nums1和以(0, j - 1]nums2的最长公共子序列（节省初始化的过程）</li>
<li>if(nums[i - 1] == nums[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1 else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</li>
<li>dp[i][0] = 0, dp[0][j] = 0（因为i-1和j-1的子序列为空）（是由三个方向推出来的，所以要初始化第一行第一列）</li>
<li>根据数值推导所需要的方向来确定遍历顺序，从上到下从左到右</li>
</ul>
<h3 id="、不相交的线">2、不相交的线</h3>
<ul>
<li>最长公共子序列</li>
</ul>
<h3 id="、最大子序和">3、最大子序和</h3>
<ul>
<li>dp[i] = 以i为结尾的最大连续子序列的和</li>
<li>dp[i] = max(dp[i - 1] + nums[i], nums[i])（延续前面的情况或者前面的都不要了从这一个开始）</li>
<li>dp[0] = nums[0]</li>
<li>从前往后遍历</li>
</ul>
<h3 id="、判断子序列">4、判断子序列</h3>
<ul>
<li>最长公共子序列</li>
<li>dp[i][j]：以i - 1、j - 1为结尾的相同子序列长度，若长度为s则说明为真</li>
<li>if(nums[i - 1] == nums[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1 else dp[i][j] = dp[i][j - 1]（只能在t里面进行元素删除）</li>
</ul>

